// chatbot.js
const express = require('express');
const axios = require('axios');
const fs = require('fs');
const path = require('path');

const app = express();
app.use(express.json());

// Criar diret√≥rio para salvar imagens se n√£o existir
const IMAGES_DIR = path.join(__dirname, 'images');
if (!fs.existsSync(IMAGES_DIR)) {
  fs.mkdirSync(IMAGES_DIR, { recursive: true });
}

// Sess√µes dos usu√°rios
const sessions = {};

const EVOLUTION_URL = process.env.EVOLUTION_URL || 'http://evolution-api:8080';
const API_KEY = process.env.API_KEY || 'fcd76aa8-fb1b-48f6-887c-ca8fe566b079';
const INSTANCE_NAME = process.env.INSTANCE_NAME || 'chatbot';

// Estados do fluxo
const STATES = {
  INIT: 'init',
  WAITING_SERVICE_CHOICE: 'waiting_service_choice',
  WAITING_CATEGORY: 'waiting_category',
  WAITING_LOCATION: 'waiting_location',
  WAITING_PHOTO: 'waiting_photo',
  WAITING_DESCRIPTION: 'waiting_description',
  WAITING_LOCATION_COLETA: 'waiting_location_coleta'
};

// Categorias de ocorr√™ncias
const CATEGORIES = {
  1: 'Coleta de lixo',
  2: 'Ilumina√ß√£o p√∫blica',
  3: 'Buraco na rua',
  4: 'Descarte de lixo incorreto',
  5: 'Alagamento',
  6: 'Elogio',
  7: 'Outros'
};

// Webhook recebe mensagens do WhatsApp
app.post('/webhook', async (req, res) => {
  try {
    console.log('üì© Webhook recebido:', JSON.stringify(req.body, null, 2));

    // Evolution API envia a estrutura no formato: { event, instance, data }
    const { event, data } = req.body;

    // Ignorar eventos que n√£o s√£o mensagens recebidas
    if (event !== 'messages.upsert') {
      return res.sendStatus(200);
    }

    // Verificar se tem dados da mensagem
    if (!data || !data.key || !data.message) {
      console.log('‚ö†Ô∏è Webhook sem dados v√°lidos');
      return res.sendStatus(200);
    }

    const { key, message } = data;
    const userId = key.remoteJid;

    // Ignorar mensagens enviadas por n√≥s mesmos
    if (key.fromMe) {
      return res.sendStatus(200);
    }

    await handleMessage(userId, message, key);
    res.sendStatus(200);
  } catch (error) {
    console.error('‚ùå Erro no webhook:', error);
    res.status(500).json({ error: error.message });
  }
});

async function handleMessage(userId, message, key) {
  // Inicializa sess√£o
  if (!sessions[userId]) {
    sessions[userId] = {
      state: STATES.INIT,
      data: {}
    };
  }

  const session = sessions[userId];

  switch (session.state) {
    case STATES.INIT:
      const serviceMenu = 'üëã Ol√°! Bem-vindo ao *Zeladoria Digital*!\n\n' +
        'Como posso te ajudar hoje?\n\n' +
        '1Ô∏è‚É£ Registrar uma ocorr√™ncia\n' +
        '2Ô∏è‚É£ Consultar dia da coleta de lixo\n\n' +
        'Digite *1* ou *2*:';

      await sendMessage(userId, serviceMenu);
      session.state = STATES.WAITING_SERVICE_CHOICE;
      break;

    case STATES.WAITING_SERVICE_CHOICE:
      const serviceChoice = parseInt(message.conversation || message.extendedTextMessage?.text);

      if (serviceChoice === 1) {
        // Fluxo de registrar ocorr√™ncia
        const categoryMenu = '*Escolha a categoria da ocorr√™ncia:*\n\n' +
          '1Ô∏è‚É£ Coleta de lixo\n' +
          '2Ô∏è‚É£ Ilumina√ß√£o p√∫blica\n' +
          '3Ô∏è‚É£ Buraco na rua\n' +
          '4Ô∏è‚É£ Descarte de lixo incorreto\n' +
          '5Ô∏è‚É£ Alagamento\n' +
          '6Ô∏è‚É£ Elogio\n' +
          '7Ô∏è‚É£ Outros\n\n' +
          'Digite o *n√∫mero* da categoria:';

        await sendMessage(userId, categoryMenu);
        session.state = STATES.WAITING_CATEGORY;
      } else if (serviceChoice === 2) {
        // Fluxo de consultar dia de coleta
        await sendMessage(userId, 'üóëÔ∏è *Consulta de Hor√°rio de Coleta*\n\nPor favor, envie sua *localiza√ß√£o* (use o √≠cone üìé > Localiza√ß√£o)');
        session.state = STATES.WAITING_LOCATION_COLETA;
      } else {
        await sendMessage(userId, '‚ùå Op√ß√£o inv√°lida. Por favor, digite *1* para registrar ocorr√™ncia ou *2* para consultar coleta de lixo.');
      }
      break;

    case STATES.WAITING_CATEGORY:
      const categoryNumber = parseInt(message.conversation || message.extendedTextMessage?.text);

      if (categoryNumber >= 1 && categoryNumber <= 7) {
        session.data.category = categoryNumber;
        session.data.categoryName = CATEGORIES[categoryNumber];

        await sendMessage(userId, `‚úÖ Categoria selecionada: *${CATEGORIES[categoryNumber]}*\n\nAgora, envie sua *localiza√ß√£o* (use o √≠cone üìé > Localiza√ß√£o)`);
        session.state = STATES.WAITING_LOCATION;
      } else {
        await sendMessage(userId, '‚ùå N√∫mero inv√°lido. Por favor, escolha um n√∫mero de 1 a 7.');
      }
      break;

    case STATES.WAITING_LOCATION:
      if (message.locationMessage) {
        const { degreesLatitude, degreesLongitude } = message.locationMessage;
        session.data.latitude = degreesLatitude;
        session.data.longitude = degreesLongitude;
        
        await sendMessage(userId, 'üìç Localiza√ß√£o recebida!\n\nAgora envie uma *foto do local* (ou digite "pular" se n√£o tiver foto)');
        session.state = STATES.WAITING_PHOTO;
      } else {
        await sendMessage(userId, '‚ùå Por favor, envie uma localiza√ß√£o v√°lida.');
      }
      break;

    case STATES.WAITING_PHOTO:
      if (message.imageMessage) {
        // Download da imagem
        const imageUrl = await downloadMedia(message.imageMessage, key);
        session.data.photo = imageUrl;
        
        await sendMessage(userId, 'üì∏ Foto recebida!\n\nAgora descreva o *problema* encontrado:');
        session.state = STATES.WAITING_DESCRIPTION;
      } else if (message.conversation?.toLowerCase() === 'pular') {
        session.data.photo = null;
        await sendMessage(userId, '‚è≠Ô∏è Ok, sem foto.\n\nAgora descreva o *problema* encontrado:');
        session.state = STATES.WAITING_DESCRIPTION;
      } else {
        await sendMessage(userId, '‚ùå Envie uma foto ou digite "pular"');
      }
      break;

    case STATES.WAITING_DESCRIPTION:
      if (message.conversation || message.extendedTextMessage) {
        const description = message.conversation || message.extendedTextMessage.text;
        session.data.description = description;
        session.data.phone = userId;

        // Envia dados para sua API
        await sendToAPI(session.data);

        await sendMessage(userId, '‚úÖ *Dados recebidos com sucesso!*\n\nObrigado pelo reporte. Sua solicita√ß√£o foi registrada.');

        // Limpa sess√£o
        delete sessions[userId];
      } else {
        await sendMessage(userId, '‚ùå Por favor, envie uma descri√ß√£o em texto.');
      }
      break;

    case STATES.WAITING_LOCATION_COLETA:
      if (message.locationMessage) {
        const { degreesLatitude, degreesLongitude } = message.locationMessage;

        await sendMessage(userId, 'üîÑ Consultando hor√°rios de coleta...');

        // Consultar API de hor√°rios
        const horariosColeta = await consultarHorariosColeta(degreesLatitude, degreesLongitude);

        if (horariosColeta.success) {
          await enviarHorariosColeta(userId, horariosColeta);
        } else {
          await sendMessage(userId, `‚ùå ${horariosColeta.message}`);
        }

        // Limpa sess√£o
        delete sessions[userId];
      } else {
        await sendMessage(userId, '‚ùå Por favor, envie uma localiza√ß√£o v√°lida.');
      }
      break;
  }
}

// Envia mensagem via Evolution API
async function sendMessage(phone, text) {
  await axios.post(
    `${EVOLUTION_URL}/message/sendText/${INSTANCE_NAME}`,
    {
      number: phone,
      text: text
    },
    {
      headers: { 'apikey': API_KEY }
    }
  );
}

// Download de m√≠dia
async function downloadMedia(imageMessage, key) {
  try {
    console.log('üì• Baixando imagem...');

    // Obter a imagem em base64 via Evolution API
    const response = await axios.post(
      `${EVOLUTION_URL}/chat/getBase64FromMediaMessage/${INSTANCE_NAME}`,
      {
        message: {
          key: key,
          message: {
            imageMessage: imageMessage
          }
        }
      },
      {
        headers: { 'apikey': API_KEY }
      }
    );

    const base64Data = response.data.base64;

    // Gerar nome √∫nico para o arquivo
    const timestamp = Date.now();
    const filename = `image_${timestamp}.jpg`;
    const filepath = path.join(IMAGES_DIR, filename);

    // Remover o prefixo data:image/jpeg;base64, se existir
    const base64Image = base64Data.replace(/^data:image\/\w+;base64,/, '');

    // Salvar imagem localmente
    fs.writeFileSync(filepath, base64Image, 'base64');

    console.log('‚úÖ Imagem salva em:', filepath);

    return filepath;
  } catch (error) {
    console.error('‚ùå Erro ao baixar imagem:', error.message);
    console.error('Detalhes do erro:', error.response?.data || error);
    return null;
  }
}

// Consulta hor√°rios de coleta
async function consultarHorariosColeta(latitude, longitude) {
  try {
    console.log(`üîç Consultando hor√°rios para: lat=${latitude}, lon=${longitude}`);

    const response = await axios.get('http://3.90.208.60:3080/api/v1/HorarioColeta/consultar', {
      params: {
        latitude: latitude,
        longitude: longitude
      }
    });

    console.log('‚úÖ Hor√°rios encontrados:', JSON.stringify(response.data, null, 2));
    return response.data;
  } catch (error) {
    console.error('‚ùå Erro ao consultar hor√°rios:', error.message);
    if (error.response) {
      console.error('Status:', error.response.status);
      console.error('Dados:', error.response.data);
      return error.response.data || { success: false, message: 'Erro ao consultar hor√°rios' };
    }
    return { success: false, message: 'Erro ao consultar hor√°rios' };
  }
}

// Formata e envia hor√°rios de coleta para o usu√°rio
async function enviarHorariosColeta(userId, data) {
  const { bairro, horariosColeta } = data;

  let mensagem = `üìç *Bairro:* ${bairro.nome}\n`;
  mensagem += `üìè *Dist√¢ncia:* ${Math.round(bairro.distanciaMetros)}m\n\n`;
  mensagem += `üóëÔ∏è *Hor√°rios de Coleta:*\n\n`;

  if (horariosColeta && horariosColeta.length > 0) {
    horariosColeta.forEach(h => {
      mensagem += `üìÖ *${h.diaSemanaDescricao}*\n`;
      mensagem += `   ‚è∞ ${h.horario}\n`;
      mensagem += `   üåì ${h.turno}\n`;
      if (h.nomeEmpresa) {
        mensagem += `   üè¢ ${h.nomeEmpresa}\n`;
      }
      mensagem += '\n';
    });
  } else {
    mensagem += 'Nenhum hor√°rio de coleta encontrado para este bairro.\n';
  }

  mensagem += '‚úÖ Lembre-se de colocar o lixo na cal√ßada no dia e hor√°rio indicados!';

  await sendMessage(userId, mensagem);
}

// Envia para sua API final
async function sendToAPI(data) {
  console.log('üìä Dados recebidos para processar:');
  console.log('=====================================');
  console.log('üì± Telefone:', data.phone);
  console.log('üè∑Ô∏è  Categoria:', `${data.category} - ${data.categoryName}`);
  console.log('üìç Latitude:', data.latitude);
  console.log('üìç Longitude:', data.longitude);
  console.log('üì∏ Foto:', data.photo || 'Sem foto');
  console.log('üìù Descri√ß√£o:', data.description);
  console.log('üïê Timestamp:', new Date().toISOString());
  console.log('=====================================');

  try {
    // Extrair apenas n√∫meros do telefone
    const phoneNumber = data.phone.replace(/\D/g, '');

    const payload = {
      telefone: phoneNumber,
      latitude: data.longitude, // API espera longitude no campo latitude
      longitude: data.latitude,  // API espera latitude no campo longitude
      descricao: data.description,
      fotoUrlPath: data.photo || 'sem_foto',
      categoria: data.category
    };

    console.log('üì§ Enviando para API Zeladoria Digital...');
    console.log('Payload:', JSON.stringify(payload, null, 2));

    const response = await axios.post('http://3.90.208.60:3080/api/v1/Ocorrencias', payload, {
      headers: {
        'accept': '*/*',
        'Content-Type': 'application/json'
      }
    });

    console.log('‚úÖ Ocorr√™ncia registrada com sucesso!');
    console.log('Resposta da API:', JSON.stringify(response.data, null, 2));

    return response.data;
  } catch (error) {
    console.error('‚ùå Erro ao enviar para API:', error.message);
    if (error.response) {
      console.error('Status:', error.response.status);
      console.error('Dados:', JSON.stringify(error.response.data, null, 2));
    }
    throw error;
  }
}

// Endpoint gen√©rico para enviar mensagens
app.post('/send-message', async (req, res) => {
  try {
    const { phone, message } = req.body;

    // Valida√ß√£o
    if (!phone || !message) {
      return res.status(400).json({
        success: false,
        error: 'Campos obrigat√≥rios: phone e message'
      });
    }

    // Normalizar telefone (aceita com ou sem @s.whatsapp.net)
    const normalizedPhone = phone.includes('@') ? phone : `${phone}@s.whatsapp.net`;

    console.log(`üì§ Enviando mensagem para: ${normalizedPhone}`);
    console.log(`üìù Mensagem: ${message}`);

    // Enviar mensagem via Evolution API
    await sendMessage(normalizedPhone, message);

    res.json({
      success: true,
      message: 'Mensagem enviada com sucesso',
      to: normalizedPhone
    });

  } catch (error) {
    console.error('‚ùå Erro ao enviar mensagem:', error.message);
    res.status(500).json({
      success: false,
      error: error.message
    });
  }
});

// Endpoint para visualizar imagens por path completo ou filename
app.get('/image', (req, res) => {
  try {
    const { path: imagePath } = req.query;

    if (!imagePath) {
      return res.status(400).json({
        success: false,
        error: 'Par√¢metro "path" √© obrigat√≥rio. Exemplo: /image?path=/app/images/image_123.jpg'
      });
    }

    // Extrair apenas o nome do arquivo do path
    // Aceita tanto "/app/images/image_123.jpg" quanto "image_123.jpg"
    const filename = path.basename(imagePath);

    // Validar filename para evitar path traversal
    if (filename.includes('..') || filename.includes('/')) {
      return res.status(400).json({
        success: false,
        error: 'Nome de arquivo inv√°lido'
      });
    }

    const filepath = path.join(IMAGES_DIR, filename);

    // Verificar se o arquivo existe
    if (!fs.existsSync(filepath)) {
      return res.status(404).json({
        success: false,
        error: 'Imagem n√£o encontrada',
        searchedPath: filepath
      });
    }

    // Enviar a imagem
    res.sendFile(filepath);
  } catch (error) {
    console.error('‚ùå Erro ao buscar imagem:', error.message);
    res.status(500).json({
      success: false,
      error: error.message
    });
  }
});

// Endpoint para listar todas as imagens
app.get('/images', (_req, res) => {
  try {
    const files = fs.readdirSync(IMAGES_DIR);

    const images = files
      .filter(file => file.match(/\.(jpg|jpeg|png|gif)$/i))
      .map(file => ({
        filename: file,
        url: `/image?path=/app/images/${file}`,
        fullPath: `/app/images/${file}`,
        createdAt: fs.statSync(path.join(IMAGES_DIR, file)).mtime
      }))
      .sort((a, b) => b.createdAt - a.createdAt); // Mais recentes primeiro

    res.json({
      success: true,
      total: images.length,
      images: images
    });
  } catch (error) {
    console.error('‚ùå Erro ao listar imagens:', error.message);
    res.status(500).json({
      success: false,
      error: error.message
    });
  }
});

// Endpoint de health check
app.get('/health', (_req, res) => {
  res.json({
    status: 'ok',
    timestamp: new Date().toISOString(),
    service: 'chatbot-api'
  });
});

app.listen(3000, () => {
  console.log('Chatbot rodando na porta 3000');
  console.log('');
  console.log('üìã Endpoints dispon√≠veis:');
  console.log('  POST /webhook                         - Recebe mensagens do WhatsApp');
  console.log('  POST /send-message                    - Envia mensagens (phone, message)');
  console.log('  GET  /images                          - Lista todas as imagens');
  console.log('  GET  /image?path=/app/images/xxx.jpg  - Visualiza imagem pelo path');
  console.log('  GET  /health                          - Health check');
});